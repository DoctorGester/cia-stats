extends /base.jade

block append head
    script(type="text/javascript", src="/public/scripts/JSONP.js")
    script(type="text/javascript", src="/public/scripts/keyvalues.js")
    script(type="text/javascript", src="/public/scripts/transparency.min.js")

block content
    style.
        #data {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        .hero {
            display: flex;
            flex-direction: row;
            flex-basis: 50%;
            margin-bottom: 60px;
        }

        .hero .image {
            max-width: 128px;
            border-radius: 3px;
        }

        .hero .ability img {
            border-radius: 3px;
            width: 64px;
            height: 64px;
        }

        .hero .ability span {
            align-self: center;
        }

        .hero .hero-right .description {
            margin-left: 10px;
        }

        .hero .hero-left {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .hero .hero-left .hero-details {
            display: flex;
            flex-direction: column;
        }

        .hero .hero-right .abilities {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .hero .hero-right .abilities .ability {
            display: flex;
            flex-direction: row;
            margin: 4px;
        }

        .hero .hero-right .abilities .hidden .ability .sub-image  {
            visibility: hidden;
        }

        .hero .hero-right .abilities .ability .image {
            margin-right: 4px;
        }

    #data
        .hero
            .hero-left
                img.image
                .name
            .hero-right
                .abilities
                    .ability
                        img.image
                        img.sub-image(data-bind="subImage")
                        span.description(data-bind="description")
                        span /
                        span(data-bind="subDescription")

    script.
        function loadKV(target, kv) {
            target.load(atob(kv));
        }

        var heroes = new KeyValues();
        var abilities = new KeyValues();
        var strings = new KeyValues();

        loadKV(heroes, "#{model.heroes}");
        loadKV(abilities, "#{model.abilities}");
        //loadKV(strings, "#{model.localization}");

        var model = [];

        heroes.value.forEach(function (hero) {
            var heroModel = {};

            heroModel.abilities = [];

            for (var i = 1; i < 10; i++) {
                var key = hero.findKey("Ability" + i);

                heroModel.name = hero.findKey("override_hero").value.substr("npc_dota_hero_".length);

                if (key) {
                    var abilityName = key.value;
                    var originalName = abilityName;
                    var ability = abilities.findKey(abilityName);
                    var isSub = false;

                    if (abilityName.startsWith("placeholder")) {
                        continue;
                    }

                    if (abilityName.endsWith("_sub")) {
                        isSub = true;
                        abilityName = abilityName.substr(0, abilityName.length - "_sub".length);
                    }

                    if (ability) {
                        var abilityModel = {};
                        abilityModel.name = abilityName;

                        var found = false;

                        heroModel.abilities.forEach(function (value) {
                            if (value.name == abilityName) {
                                found = true;
                                abilityModel = value;
                                return false;
                            }
                        });

                        if (!isSub) {
                            abilityModel.image = ability.findKey("AbilityTextureName").value;
                            abilityModel.description = abilityName;
                        } else {
                            abilityModel.subImage = ability.findKey("AbilityTextureName").value;
                            abilityModel.subDescription = originalName;
                        }

                        if (!found) {
                            heroModel.abilities.push(abilityModel);
                        }
                    } else {
                        console.log(abilityName + " not found");
                    }
                }
            }

            if ((hero.findKey("Disabled") || {}).value === "true") {
                return;
            }

            if (hero.findKey("Order")) {
                model.push(heroModel);
            }
        });

        var directives = {
            image: {
                src: function () {
                    return "http://cdn.dota2.com/apps/dota2/images/heroes/" + this.name + "_vert.jpg";
                }
            },
            abilities: {
                image: {
                    src: function () {
                        return "http://cdn.dota2.com/apps/dota2/images/abilities/" + this.image + "_hp1.png";
                    }
                },
                subImage: {
                    src: function () {
                        if (!this.subImage) {
                            return null;
                        }

                        return "http://cdn.dota2.com/apps/dota2/images/abilities/" + this.subImage + "_hp1.png";
                    },
                    style: function () {
                        if (!this.subImage) {
                            return "visibility: hidden;";
                        }
                    }
                }
            }
        };

        Transparency.render(document.getElementById("data"), model, directives);