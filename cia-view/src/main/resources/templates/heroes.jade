extends base.jade

block append head
    script(type="text/javascript", src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js")
    script(type="text/javascript", src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular-sanitize.js")
    script(type="text/javascript", src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular-route.js")
    script(type="text/javascript", src="https://code.highcharts.com/highcharts.js")
    script(type="text/javascript", src="/scripts/highcharts-ng.min.js")
    base(href="/")
    block title
        title Crumbling Island Arena | Heroes

block content
    style.
        #heroList {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
        }

        #heroList > a {
            margin: 8px 8px 0 8px;
            object-fit: scale-down;
        }

        #heroList > a img {
            border-radius: 3px;
        }

        @media (max-width: 1024px) {
            #heroList > img {
                max-width: 96px;
            }
        }

        #heroDetails .ability img {
            border-radius: 3px;
            width: 64px;
            height: 64px;
        }

        #heroDetails .ability span {
            align-self: center;
        }

        #heroDetails .hero-right .description {
            margin-left: 16px;
            font-family: "Open Sans", sans-serif;
        }

        #heroDetails .hero-right .abilities {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        #heroDetails .hero-right .abilities .ability-block {
            display: flex;
            flex-direction: column;
            margin: 4px;
            border: 1px solid #eee;
            padding: 12px;
            border-radius: 3px;
        }

        #heroDetails .hero-right .abilities .ability {
            display: flex;
            flex-direction: row;
            margin: 4px;
        }

        #heroDetails .hero-right .abilities .ability .image-block {
            display: flex;
            flex-direction: column;
            position: relative;
            width: 64px;
            height: 64px;
            margin-right: 4px;
            align-self: center;
        }

        #heroDetails .hero-right .abilities .ability .image-block .image {
            position: relative;
        }

        #heroDetails .hero-right .abilities .ability .image-block .cooldown-text {
            position: absolute;
            color: white;
            background-color: #2d2d29;
            text-align: center;
            border-radius: 4px;
            left: 100%;
            top: 100%;
            transform: translate(-80%, -80%);
            padding-left: 5px;
            padding-right: 5px;
        }

        #heroDetails .hero-right .abilities .sub {
            background-color: antiquewhite;
            border-radius: 3px;
        }

        #heroDetails {
            display: flex;
            flex-direction: column;
            line-height: 1.4em;
        }

        #heroDetails .hero-top {
            align-content: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #heroDetails .hero-top img {
            border-radius: 4px;
        }

        #heroDetails .hero-top .name {
            margin-top: 24px;
            margin-bottom: 40px;
            font-size: 32px;
            text-transform: uppercase;
            font-family: "Raleway", "Open Sans", sans-serif;
            letter-spacing: 2px;
        }

        #heroDetails .hero-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        #heroDetails .hero-bar a {
            font-size: 28px;
            font-family: "Raleway", sans-serif;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #heroDetails .hero-bar > a {
            display: flex;
            justify-content: center;
            flex-direction: column;
        }

        #heroDetails .hero-stats {
            margin-top: 40px;
        }

        .language-selector {
            display: flex;
        }

        .language-selector > a {
            margin: 10px;
            cursor: pointer;
        }

    #app(ng-app="app")
        #main(ng-controller="HeroesCtrl" ng-cloak)
            ng-view
    script.
        function parseKV(string, targetObject) {
            var index = 0;
            var state = 0;
            var buffer = "";
            var lastKey = null;
            var prevToken = null;

            while (index < string.length) {
                var token = string.charAt(index);

                if (token == "}" && state != 1 && state != 3) {
                    return index;
                }

                if (token == "\"" && prevToken != "\\") {
                    if (state == 0) {
                        state = 1;
                    } else if (state == 1) {
                        state = 2;
                        lastKey = buffer;
                        buffer = "";
                    } else if (state == 2) {
                        state = 3;
                    } else if (state == 3) {
                        targetObject[lastKey] = buffer;
                        buffer = "";
                        state = 0;
                    }
                } else if (token == "{" && state == 2) {
                    var internal = {};
                    index += parseKV(string.substring(index), internal);
                    targetObject[lastKey] = internal;
                    state = 0;
                } else if (state == 1 || state == 3) {
                    buffer = buffer + token;
                }

                prevToken = token;
                index++;
            }

            return index;
        }

        function getLang() {
            if (navigator.languages != undefined)
                return navigator.languages[0] || "";
            else
                return navigator.language || "";
        }

        function kvToObject(base64) {
            var obj = {};
            parseKV(decodeURIComponent(escape(atob(base64))), obj);
            return obj;
        }

        var model = [];

        var app = angular.module('app', [ "ngSanitize", "ngRoute", "highcharts-ng" ]);

        app.config(function($routeProvider, $locationProvider) {
            $routeProvider.when("/heroes/:hero", {
                templateUrl: "/templates/hero.html",
                controller: "HeroesCtrl"
            });

            $routeProvider.when("/heroes", {
                templateUrl: "/templates/heroList.html",
                controller: "HeroesCtrl"
            });

            $locationProvider.html5Mode(true);
        });

        app.controller('HeroesCtrl', function ($scope, $http, $filter, $routeParams) {
            var heroes = kvToObject("#{model.heroes}").DOTAHeroes;
            heroes = Object.keys(heroes).filter(function(key) {
                var hero = heroes[key];
                return (!hero.Disabled || hero.Disabled == "false") && hero.Order;
            }).map(function (key) {
                return heroes[key];
            });

            heroes.forEach(function(hero) {
                hero.name = hero.override_hero.substr('npc_dota_hero_'.length);
            });

            var tokens = kvToObject("#{model.localization}").addon.Tokens;
            var tokensRU = kvToObject("#{model.localizationRU}").addon.Tokens;

            $scope.heroes = heroes;

            $scope.selectEnglish = function() {
                $scope.tokens = tokens;
            };

            $scope.selectRussian = function () {
                $scope.tokens = tokensRU;
            };

            if (getLang().indexOf("ru") !== -1) {
                $scope.selectRussian();
            } else {
                $scope.selectEnglish();
            }

            var allAbilities = kvToObject("#{model.abilities}").DOTAAbilities;

            $scope.getAbilityImage = function(ability, sub) {
                var template = "http://cdn.dota2.com/apps/dota2/images/abilities/%s_hp1.png";

                if (ability.customIcon) {
                    template = "https://github.com/DoctorGester/crumbling-island-arena/blob/master/content/panorama/images/custom_game/%s?raw=true";
                }

                if (sub) {
                    return template.replace(/%s/, ability.subImage);
                }

                return template.replace(/%s/, ability.image);
            };

            $scope.getAbilityDescription = function(ability, sub) {
                var token = $scope.tokens['AbilityTooltip_' + (sub ? ability.subName : ability.name)];

                return token.replace(/\\"/g, "\"").replace(/\\\\\\\\/g, "");
            };

            $scope.winrateConfig = {
                loading: true,
                options: {
                    chart: {
                        type: "line"
                    },
                    tooltip: {
                        formatter: function () {
                            return this.y.toFixed(1) + ' % across ' + this.point.games + ' games';
                        }
                    },
                    legend: {
                        enabled: false
                    }
                },
                title: {
                    text: "Winrate"
                },
                xAxis: {
                    type: 'datetime',
                    title: {
                        text: 'Date'
                    }
                },
                yAxis: {
                    min: 25,
                    max: 75
                }
            };

            var loadHeroWinRates = function(hero) {
                $scope.winrateConfig.loading = true;

                $http.get("/stats/" + hero.name)
                    .then(function(response) {
                        var seriesResult = [];
                        angular.forEach(response.data, function(value, key) {
                            seriesResult.push({ x: new Date(key), y: value.winRate * 100, games: value.games })
                        }, seriesResult);

                        seriesResult = $filter('orderBy')(seriesResult, "'x'");

                        $scope.winrateConfig.series = [{ data: seriesResult }];
                        $scope.winrateConfig.loading = false;
                    });
            };

            $scope.selectHero = function(hero) {
                $scope.selectedHero = hero;

                if (!hero) {
                    return;
                }

                loadHeroWinRates(hero);

                var customIcons = hero.CustomIcons || {};

                var abilities = [];

                for (var i = 1; i < 10; i++) {
                    var abilityName = hero["Ability" + i];

                    if (!abilityName) {
                        continue;
                    }

                    var originalName = abilityName;
                    var ability = allAbilities[abilityName];
                    var isSub = false;

                    if (abilityName.startsWith("placeholder")) {
                        continue;
                    }

                    if (abilityName.endsWith("_sub")) {
                        isSub = true;
                        abilityName = abilityName.substr(0, abilityName.length - "_sub".length);
                    }

                    if (ability) {
                        var abilityModel = {};

                        var found = false;

                        abilities.forEach(function (value) {
                            if (value.name == abilityName) {
                                found = true;
                                abilityModel = value;
                                return false;
                            }
                        });

                        var customIcon = customIcons[originalName];
                        var abilityImage = customIcon || ability.AbilityTextureName;

                        abilityModel.customIcon = customIcon;

                        if (!isSub) {
                            abilityModel.image = abilityImage;
                            abilityModel.name = abilityName;
                            abilityModel.cooldown = parseFloat(ability.AbilityCooldown);
                        } else {
                            abilityModel.subImage = abilityImage;
                            abilityModel.subName = originalName;
                            abilityModel.subCooldown = parseFloat(ability.AbilityCooldown);
                        }

                        if (!found) {
                            abilities.push(abilityModel);
                        }
                    } else {
                        console.log(abilityName + " not found");
                    }
                }

                $scope.abilities = abilities;
            };

            if ($routeParams.hero) {
                heroes.forEach(function (hero) {
                    if (hero.name === $routeParams.hero) {
                        $scope.selectHero(hero);
                    }
                });
            }
        });